var tipuesearch = {"pages":[{"title":"Sistema Mayor","text":"¿Qué es? Denominado Major System [1] [2] en inglés, se trata de un sistema mnemotécnico para memorizar números de forma eficiente. Si intentamos memorizar una ristra de números sin ningún método, nos resultará muy complicado y tedioso. Sin embargo haciendo que cada dígito se corresponda con una consonante y ayudándonos de vocales podremos formar una palabra para cada par de dígitos que contenga las correspondientes consonantes en el orden correcto. De esta forma habremos codificado los números en palabras, esas palabras las podremos convertir en imágenes , que podremos visualizar mentalmente, e incluso formar una historia con la sucesión de estas imágenes y por tanto recordar con mayor facilidad. Correspondencia dígito consonante Esta es la correspondencia que yo utilizo. Correspondencia Dígito Consonantes 0 r, rr 1 d, t 2 n 3 m 4 c, k, q 5 l 6 s, z 7 f 8 ch, g, j 9 b, v, p Ejemplos Por ejemplo si queremos memorizar los primeros decimales del número \\(\\pi\\) \\begin{equation*} \\pi = 3.1415926535 \\ldots \\end{equation*} Podríamos hacerlo de la siguiente forma: Emparejamos los dígitos. Buscamos una palabra para cada par de dígitos. Convertimos las palabras en imágenes y formamos una historia. Número Palabra 14 ático 15 tila 92 avión 65 sol 35 miel Subo al ático de mi casa y decido tomarme una tila para relajarme. Cuando de repente un avión choca contra la casa creando una gran brecha en la pared. La brecha en la pared deja pasar unos rayos de sol y apenas distingo que es lo que lleva en la mano el piloto que se esta bajando del avión. Se trata de un tarro de miel , me comenta que si se lo añado a la tila me sentará mucho mejor… Esta historia alocada e inverosímil permanecerá en nuestra cabeza por mucho más tiempo que si repetimos una y otra vez los números que queremos memorizar. He creado una herramienta (Major system tool [3] ) para poder encontrar más fácilmente palabras para ciertos números. Referencias [1] Major System Wikipedia [2] Major System Art Of memory [3] Major system tool","tags":"Memoria","url":"sistema-mayor","loc":"sistema-mayor"},{"title":"My first Vim plugin","text":"After been using Vim for a long time. I've decided to venture into the creation of my first vim plugin. It's a very simple plugin that allows you to iterate over a list of possible dictionaries used for spell checking. The idea is to be able to activate the spell checking ( :set spell ) in case it is deactivated and iterate over a configurable list of languages. The following function accomplish the objective. let g :SpellLangList = get ( g : , 'SpellLangList' , [] ) \" Cycle through spelllang list and toggle spell function ! ToggleCycleSpellLang () if ! & spell setlocal spell else let l :lang_index = index ( g :SpellLangList , & spelllang ) let l :lang_index = ( l :lang_index + 1 ) % len ( g :SpellLangList ) let & spelllang = g :SpellLangList[ l :lang_index] if l :lang_index == 0 setlocal nospell endif endif endfunction It'll be possible to configure the list of languages and the keybindings as follows: let g :SpellLangList = [ \"en_us\" , \"es\" , \"en_us,es\" ] nnoremap < F6 > : call ToggleCycleSpellLang ()< CR > Consequently pressing F6 will enable spell check for the current buffer ( :set spell ), and pressing F6 successively will be changing current language used for spell checking ( :set spelllang=es ) until finally disable spell check again ( :set nospell ). I've uploaded the plugin to a github repository, and I've added similar funcionality related with quickfix and location windows.","tags":"Programming","url":"my-first-vim-plugin","loc":"my-first-vim-plugin"},{"title":"Mutable objects in python","text":"Let's assume we have defined the following function: def f ( x , l = []): for i in range ( x ): l . append ( i ) print ( l ) If we have to guess what is the output of these calls to the function. A lot of us will think is: >>> f ( 2 ) [ 0 , 1 ] >>> f ( 3 , [ 3 , 4 , 5 ]) [ 3 , 4 , 5 , 0 , 1 , 2 ] >>> f ( 3 ) # WRONG RESULT [ 0 , 1 , 2 ] However, the correct result is: >>> f ( 2 ) [ 0 , 1 ] >>> f ( 3 , [ 3 , 4 , 5 ]) [ 3 , 4 , 5 , 0 , 1 , 2 ] >>> f ( 3 ) # CORRECT RESULT [ 0 , 1 , 0 , 1 , 2 ] This is due to the fact that lists in python are mutable objects , and therefore whenever they are defined as default parameters in a function, the list behaves as a global variable common to all function's executions. When we call to f(2) for the first time, the value [] is being used by default. But when f(3) is executed the same global variable used when f(2) was called is used, which last value is [0, 1] . Table of objects in python Object Mutable bool No int No float No list Yes tuple No str No set Yes frozenset No dict Yes Mutable objects in python are passed by reference. Immutable objects is like they were being passed by value. An example of that is the following code: def f ( l ): l . append ( 23 ) >>> l = [ 37 ] >>> f ( l ) >>> print ( l ) [ 37 , 23 ]","tags":"Programming","url":"python-mutable-objects","loc":"python-mutable-objects"},{"title":"Tutorial resolver cubo a ciegas","text":"Resolver por primera vez el cubo de Rubik es un momento emocionante. Sin embargo, esta sensación no es comparable a lo que se siente al resolver el cubo a ciegas por primera vez. En esta nueva entrada os dejo una serie de videos en los que os explico como poder resolver el cubo de Rubik a ciegas. Recordad que nada se consigue de la noche a la mañana, pero cuando se consigue, ese esfuerzo se ve recompensado. Aún recuerdo la primera vez que conseguí hacer mi primer cubo de Rubik a ciegas, allá por el 2013. Y solo puedo animaros a conseguirlo si ese es vuestro objetivo.","tags":"Rubik","url":"tutorial-resolver-cubo-a-ciegas","loc":"tutorial-resolver-cubo-a-ciegas"},{"title":"Mi primer plugin en VIM","text":"Tras usar Vim durante un largo periodo de tiempo, he decidido aventurarme a hacer mi primer plugin. Se trata de un plugin muy sencillo que simplemente te permite iterar una lista de posibles diccionarios para la corrección ortográfica. La idea es que sea posible activar el corrector ortográfico ( :set spell ) en caso de que este desactivado e ir iterando por una lista configurable de idiomas. let g :SpellLangList = get ( g : , 'SpellLangList' , [] ) \" Cycle through spelllang list and toggle spell function ! ToggleCycleSpellLang () if ! & spell setlocal spell else let l :lang_index = index ( g :SpellLangList , & spelllang ) let l :lang_index = ( l :lang_index + 1 ) % len ( g :SpellLangList ) let & spelllang = g :SpellLangList[ l :lang_index] if l :lang_index == 0 setlocal nospell endif endif endfunction Se podría configurar por ejemplo con las siguientes opciones: let g :SpellLangList = [ \"en_us\" , \"es\" , \"en_us,es\" ] nnoremap < F6 > : call ToggleCycleSpellLang ()< CR > De esta manera una primera pulsación de la tecla F6 activaría la corrección ortográfica para el buffer activo, y sucesivas pulsaciones irían cambiando el idioma activo ( :set spelllang=es ) iterando la lista g:SpellLangList hasta desactivar de nuevo la corrección ortográfica ( :set nospell ). He subido el plugin a un repositorio en github y añadido alguna funcionalidad, relacionada con las ventanas quickfix y location .","tags":"Programación","url":"../my-first-vim-plugin","loc":"../my-first-vim-plugin"},{"title":"Objetos mutables en python","text":"Supongamos que tenemos definida en python la siguiente función: def f ( x , l = []): for i in range ( x ): l . append ( i ) print ( l ) Si tuviésemos que decir cual es el resultado de hacer las siguientes llamadas sucesivas a la función, muchos pensareis que el resultado que se obtendría es: >>> f ( 2 ) [ 0 , 1 ] >>> f ( 3 , [ 3 , 4 , 5 ]) [ 3 , 4 , 5 , 0 , 1 , 2 ] >>> f ( 3 ) # RESULTADO ERRONEO [ 0 , 1 , 2 ] Sin embargo, el resultado que obtenemos es el siguiente: >>> f ( 2 ) [ 0 , 1 ] >>> f ( 3 , [ 3 , 4 , 5 ]) [ 3 , 4 , 5 , 0 , 1 , 2 ] >>> f ( 3 ) # RESULTADO CORRECTO [ 0 , 1 , 0 , 1 , 2 ] Esto es debido a que las listas en python son objetos mutables y por tanto cuando son definidos como parámetros por defecto en una función, la lista se comporta como una variable global a todas las ejecuciones de la función. Cuando llamamos a f(2) por primera vez se utiliza [] que es el valor por defecto de la lista. Pero cuando se ejecuta f(3) se utiliza la misma variable global que cuando se llamó a f(2) cuyo ultimo valor es [0, 1] . Tabla de objetos en python Objeto Mutable bool No int No float No list Sí tuple No str No set Sí frozenset No dict Sí Los objetos mutables en python son pasados por referencia. A diferencia del resto que es como si fuesen pasados por valor (ya que son inmutables). Un ejemplo de ello es el siguiente código: def f ( l ): l . append ( 23 ) >>> l = [ 37 ] >>> f ( l ) >>> print ( l ) [ 37 , 23 ]","tags":"Programación","url":"../python-mutable-objects","loc":"../python-mutable-objects"}]};