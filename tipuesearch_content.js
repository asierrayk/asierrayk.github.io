var tipuesearch = {"pages":[{"title":"¿Cómo suscribirse al blog?","text":"Si quieres ser el primero en enterarte cuando haya una nueva entrada en el blog, deberás seguir alguna de estas opciones. Atom feed Se puede realizar la suscripción mediante el feed del Blog . Para ello podéis usar cualquier programa agregador. Yo en particular recomiendo Feedbro para Chrome que soporta MathJax y se pueden previsualizar correctamente las fórmulas matemáticas del Blog si se activa esta opción en la configuración. De esta forma cada vez que se publique una nueva entrada en el blog, esto se verá reflejado en la extension de chrome. Además se pueden configurar notificaciones o acciones dependiendo de ciertas condiciones. Redes Sociales A través de las redes sociales también informaré de nuevas entradas en el Blog. Por ahora únicamente a través twitter con la cuenta @placerdepensar . Sugerencias Cualquier sugerencia o aporte es bienvenido. Usa los comentarios para hablarlo.","tags":"Blog","url":"como-suscribirse-al-blog","loc":"como-suscribirse-al-blog"},{"title":"El problema que Gauss resolvió al instante","text":"Muchas veces se nos plantean problemas matemáticos abstractos y es difícil encontrar un problema de la vida real que se corresponda con ese problema abstracto. Dado un problema de matemáticas abstracto, podemos realizar un ejercicio muy curioso, que es buscar un problema concreto que implique la resolución de ese problema abstracto. El problema abstracto Estaba el profesor de Gauss cansado por el revuelo que formaban sus alumnos cuando decidió plantearles un problema que les tuviese entretenidos por un largo periodo de tiempo. El problema era el siguiente: Sumar todos los números naturales desde el 1 hasta el 100 Sin embargo, Gauss contestó casi al instante con la respuesta correcta: \\(5050\\) Búsqueda del problema concreto Un enunciado que implica resolver el problema abstracto planteado por el profesor de Gauss podría ser el siguiente: Desiderio es una persona muy despistada, es por ello que todos los años ha de comprar tantas velas como años va a cumplir, ya que no reutiliza ninguna del año anterior. ¿Cuántas velas habrá comprado el día que celebre su centésimo cumpleaños? El hecho de poder ver un problema abstracto como un problema concreto, nos acerca el problema y da más sentido a su resolución, pues la solución adquiere un significado. Note Con esto, no quiero decir que un problema abstracto del cual no se conozca un posible problema concreto deba ser ignorado. Es más, existen muchos problemas abstractos en la historia de las matemáticas que se han estudiado sin conocerse ninguna aplicación y han resultado ser de suma importancia para la humanidad. Un ejemplo es el álgebra de Boole . Resolución del problema general Vamos a plantear el caso general del problema del profesor de Gauss y resolverlo por distintos métodos: Sumar los \\(n\\) primeros números naturales. Método 1: Agrupando términos Para resolver el problema, podemos agrupar, al igual que hizo Gauss, los términos último y primero, penúltimo y segundo, tercero y antepenúltimo … 1 $$ \\begin{align*} & 1 + 2 + 3 + \\dots + (n-2) + (n-1) + n = \\\\ & \\underbrace{(n + 1) + ((n-1) + 2) + ((n-2) + 3) + \\dots}_{\\dfrac{n}{2}} = \\\\ & \\underbrace{(n + 1) + (n+1) + (n+1) + \\dots}_{\\dfrac{n}{2}} = \\\\ \\end{align*} $$ Como todos los sumandos agrupados tienen valor \\(n+1\\) y hay un total de \\(\\dfrac{n}{2}\\) , sabemos que la suma da como resultado: $$ \\dfrac{n(n+1)}{2} $$ Método 2: Manipulando Series La suma que queremos calcular se puede expresar como la siguiente serie: $$ S(n) = \\sum_{k=1}&#94;{n}k = 1 + 2 + 3 + \\dots + (n-2) + (n-1) + n $$ Si multiplicamos por \\(2\\) , entonces tenemos lo siguiente: $$ \\begin{align*} 2S(n) & = 2\\sum_{k=1}&#94;{n}k = \\sum_{k=1}&#94;{n}k + \\sum_{k=1}&#94;{n}(n+1-k) = \\\\ & = \\sum_{k=1}&#94;{n}(k + n + 1 - k) = \\sum_{k=1}&#94;{n}(n + 1) = \\\\ & = n(n+1) \\end{align*} $$ Por tanto, despejando \\(S(n)\\) tenemos que \\(S(n) = \\dfrac{n(n+1)}{2}\\) Método 3: Solución geométrica Si representamos el resultado de la suma como puntos distribuidos en el plano formando un triángulo rectángulo en el que cada fila tiene un punto más que el anterior, obtenemos la siguiente figura: Si realizamos una copia de este triángulo, podemos formar un cuadrado y contar fácilmente el número de puntos con la fórmula \\(\\text{base} \\cdot \\text{altura}\\) Por tanto el número total de puntos es \\(\\dfrac{base \\cdot altura}{2}\\) $$\\dfrac{n(n+1)}{2}$$ Está es la razón por la que estos números (la suma de los \\(n\\) primeros números naturales) son conocidos como números triangulares. Solución concreta Conociendo la solución general podemos fácilmente encontrar una solución concreta para \\(n=100\\) simplemente dando valores. La solución general para la suma de los \\(n\\) primeros términos es \\(S(n) = \\dfrac{n(n+1)}{2}\\) , por tanto para \\(n=100\\) obtendríamos \\(S(100) = \\dfrac{100 \\cdot (100 + 1)}{2} = \\dfrac{10100}{2} = 5050\\) Esto solo lo podemos hacer cuando hay que sumar un número par de términos. En caso de ser un número impar podemos llegar a la misma fórmula de manera análoga. Formando \\(\\dfrac{n-1}{2}\\) parejas de valor \\(n+1\\) , más el término que queda en el centro sin emparejar de valor \\(\\dfrac{n+1}{2}\\) . $$ \\begin{align} \\dfrac{n-1}{2}(n+1) + \\dfrac{n+1}{2} & = \\dfrac{n&#94;2-1}{2} + \\dfrac{n+1}{2} \\\\ & = \\dfrac{n&#94;2+n}{2} \\\\ & = \\dfrac{n(n+1)}{2} \\end{align} $$ ↩","tags":"Matemáticas","url":"el-problema-que-gauss-resolvio-al-instante","loc":"el-problema-que-gauss-resolvio-al-instante"},{"title":"¿La banca siempre gana?","text":"El siguiente problema ha sido planteado como tercer ejercicio de las oposiciones para profesor de secundaria en Madrid 2021 en la especialidad de matemáticas. Enunciado Un hombre acude a un banco para cobrar un cheque por valor de \\(E\\) euros y \\(C\\) céntimos. El cajero, por error, le entrega un sobre con \\(C\\) euros y \\(E\\) céntimos. El cliente no se da cuenta del error hasta que gasta 23 céntimos y, además, observa que en ese momento tiene \\(2E\\) euros y \\(2C\\) céntimos. ¿Cuál es el valor del cheque? Resolución Podemos plantear la ecuación del problema: $$ 100C+E-23 = 200E+2C $$ Despejando tenemos la siguiente ecuación Diofántica $$ -199E+98C = 23 $$ Algoritmo de Euclides Aplicamos el algoritmo de Euclides para obtener el máximo común divisor. El máximo común divisor será el último resto distinto de cero de las sucesivas divisiones o el divisor de la división con resto cero. $$ \\begin{align*} -199 & = 98 \\cdot (-3)+95 \\\\ 98 & = 95 \\cdot (1)+3 \\\\ 95 & = 3 \\cdot (31)+2 \\\\ 3 & = 2 \\cdot (1)+1 \\\\ 2 & = 1 \\cdot (2)+0 \\end{align*} $$ Como el divisor de la división exacta es \\(1\\) , tenemos que el \\(mcd(-199, 98) = 1\\) Para que la ecuación diofántica tenga solución el máximo común divisor debe dividir al término independiente de la ecuación. En nuestro caso \\(mcd(-199, 98) = 1\\) es divisor de \\(23\\) . Algoritmo de Euclides extendido El algoritmo extendido de Euclides nos permite encontrar coeficientes \\(p\\) y \\(q\\) para satisfacer la identidad de bezout. $$ -199p+98q = mcd(-199, 98) = 1 $$ fila p q r -199p + 98q = r F1 1 0 -199 -199 (1) + 98 (0) = -199 F2 0 1 98 -199 (0) + 98 (1) = 98 F3 1 3 95 -199 (1) + 98 (3) = 95 F4 -1 -2 3 -199 (-1) + 98 (-2) = 3 F5 32 65 2 -199 (32) + 98 (65) = 2 F6 -33 -67 1 -199 (-33) + 98 (-67) = 1 Para ello hemos usado las ecuaciones despejadas en el algoritmo de euclides. Las dos primeras entradas de la tabla son triviales y el resto se obtienen a partir de las anteriores. $$ \\begin{align} -199 + 98 \\cdot (3) = 95 \\rightarrow & F_3 = F_1 + 3 \\cdot F_2 \\\\ 98 + 95 \\cdot (-1) = 3 \\rightarrow & F_4 = F_2 + (-1) \\cdot F_3 \\\\ 95 + 3 \\cdot (-31) = 2 \\rightarrow & F_5 = F_3 + (-31) \\cdot F_4 \\\\ 3 + 2 \\cdot (-1) = 1 \\rightarrow & F_6 = F_4 + (-1) \\cdot F_5 \\end{align} $$ $$ p=-33 \\quad \\text{y} \\quad q=-67 $$ De manera alternativa se pueden calcular \\(p\\) y \\(q\\) partiendo de la última ecuación, despejando el resto y haciendo sustituciones sucesivas. $$ \\begin{align} & \\quad 3 - 2 = 1 \\\\ 2= 95 - 3 \\cdot (31) \\rightarrow & \\quad 3 - (95 -3 \\cdot (31)) = 1 \\\\ & \\quad 3 \\cdot 32 - 95 = 1 \\\\ 3 = 98 - 95 \\cdot (1)\\rightarrow & \\quad (98-95)\\cdot(32)-95 = 1 \\\\ & \\quad 95\\cdot(-33)+98\\cdot(32) = 1 \\\\ 95=-199-98\\cdot(-3) \\rightarrow & \\quad (-199-98\\cdot(-3))\\cdot(-33)+98\\cdot(32) = 1 \\\\ & \\quad -199\\cdot(-33) + 98\\cdot(-67) = 1 \\\\ \\end{align} $$ Solución de la ecuación diofántica Como para obtener el término independiente \\(23\\) a partir del \\(mcd(-199, 98) = 1\\) hay que multiplicar por \\(23\\) . Hacemos lo mismo con la última ecuación obtenida con el algoritmo de Euclides extendido, obteniendo una solución de las infinitas que tiene la ecuación diofántica: $$ \\begin{cases} E_0 = -759 \\\\ C_0 = -1541 \\end{cases} $$ $$ -199 (-759) + 98 (-1541) = 23 $$ La solución general para la ecuación diofántica \\(ax+by=c\\) , con una solución particular \\((x_0, y_0)\\) es la siguiente: $$ \\begin{cases} x = x_0 + \\lambda \\dfrac{b}{mcd(a,b)} \\\\ y = y_0 - \\lambda \\dfrac{a}{mcd(a,b)} \\end{cases} \\lambda \\in \\mathbb Z $$ En nuestro caso, esta es la solución general: $$ \\begin{cases} E = -759 + \\lambda \\dfrac{98}{1} \\\\ C = -1541 - \\lambda \\dfrac{-199}{1} \\end{cases} \\lambda \\in \\mathbb Z $$ Sin embargo, la solución de nuestro problema debe estar formado por números \\(E\\) y \\(C\\) naturales, donde se cumple la restricciones \\(0 < C < 100\\) y \\(0 < E < 100\\) . Si elegimos \\(\\lambda = 8\\) obtenemos nuestra solución. $$ \\begin{cases} E = -759 + 8 \\cdot \\dfrac{98}{1} = 25 \\\\ C = -1541 - 8 \\cdot \\dfrac{-199}{1} = 51 \\end{cases} $$ El valor del cheque es de \\(25\\) euros y \\(51\\) céntimos Comprobación del resultado Para comprobar que hemos obtenido la respuesta correcta basta con intercambiar los centimos por los euros: \\(51\\) euros y \\(25\\) céntimos Restar 23 céntimos: \\(51\\) euros y \\(2\\) céntimos Que es justo el doble de euros y el doble de céntimos.","tags":"Matemáticas","url":"la-banca-siempre-gana","loc":"la-banca-siempre-gana"},{"title":"Sistema Mayor","text":"¿Qué es? Denominado Major System [1] [2] en inglés, se trata de un sistema mnemotécnico para memorizar números de forma eficiente. Si intentamos memorizar una ristra de números sin ningún método, nos resultará muy complicado y tedioso. Sin embargo haciendo que cada dígito se corresponda con una consonante y ayudándonos de vocales podremos formar una palabra para cada par de dígitos que contenga las correspondientes consonantes en el orden correcto. De esta forma habremos codificado los números en palabras. Esas palabras las podremos convertir en imágenes que son mucho más fáciles de visualizar mentalmente. Con la sucesión de estas imágenes se puede formar una historia y por tanto recordar con mayor facilidad. Correspondencia dígito consonante Esta es la correspondencia que yo utilizo. Correspondencia Dígito Consonantes 0 r, rr 1 d, t 2 n 3 m 4 c, k, q 5 l 6 s, z 7 f 8 ch, g, j 9 b, v, p Ejemplos Por ejemplo si queremos memorizar los primeros decimales del número \\(\\pi\\) \\begin{equation*} \\pi = 3.1415926535 \\ldots \\end{equation*} Podríamos hacerlo de la siguiente forma: Emparejamos los dígitos. Buscamos una palabra para cada par de dígitos. Convertimos las palabras en imágenes y formamos una historia. Número Palabra 14 ático 15 tila 92 avión 65 sol 35 miel Subo al ático de mi casa y decido tomarme una tila para relajarme. Cuando de repente un avión choca contra la casa creando una gran brecha en la pared. La brecha en la pared deja pasar unos rayos de sol y apenas distingo que es lo que lleva en la mano el piloto que se esta bajando del avión. Se trata de un tarro de miel , me comenta que si se lo añado a la tila me sentará mucho mejor… Esta historia alocada e inverosímil permanecerá en nuestra cabeza por mucho más tiempo que si repetimos una y otra vez los números que queremos memorizar. He creado una herramienta (Major system tool [3] ) para poder encontrar más fácilmente palabras para ciertos números. Referencias [1] Major System Wikipedia [2] Major System Art Of memory [3] Major system tool","tags":"Memoria","url":"sistema-mayor","loc":"sistema-mayor"},{"title":"Calendario Mental","text":"Existe un método para poder calcular en que día de la semana cayó cualquier fecha. El método es muy sencillo y hay que seguir los siguientes pasos: Calcular las claves para cada parte de la fecha: Calcular la clave del día del mes . Calcular la clave del mes . Calcular la clave para el siglo . Calcular la clave para el año . Sumar todas las claves. Restar 1 si el año es bisiesto y el mes es enero o febrero. Aplicar modulo 7 para obtener el día de la semana. 1. Cálculo de claves Vamos a ver como poder calcular cada una de las claves, para cada una de las partes de la fecha. Cada una de las claves que obtengamos la podemos simplificar aplicando modulo 7 antes de llegar al paso 2. Clave del día del mes Para calcular la clave del día del mes, simplemente debemos coger el número del mes como clave. Por ejemplo para la fecha 16 julio 1969 la clave para el día del mes es el propio número del día del mes 16 que simplificada es 2 . Clave del mes Para calcular la clave del mes debemos aplicar la correspondencia de la siguiente tabla: Mes Clave Enero 0 Febrero 3 Marzo 3 Abril 6 Mayo 1 Junio 4 Julio 6 Agosto 2 Septiembre 5 Octubre 0 Noviembre 3 Diciembre 5 Por ejemplo para la fecha 16 de julio de 1969 la clave del mes es 6 . Clave del siglo Para esta parte de la fecha, nos fijamos en el año ignorando las dos últimas cifras. Para calcular la clave del siglo deberemos tener en cuenta la siguiente correspondencia: Siglo Clave 16xx 6 17xx 4 18xx 2 19xx 0 20xx 6 21xx 4 Clave del año El cálculo de la clave del año se compone de los siguientes pasos: Nos quedamos con las dos últimas cifras del año . Por ejemplo con 1969 nos quedamos con 69. Calculamos el cociente de la división del primer paso entre 4 . Por ejemplo \\(69 = 4 \\cdot 17+1\\) , es decir, 69 entre 4 da como cociente 17. Simplificando 17 obtenemos \\(17 \\equiv 3\\) , por tanto la clave es \\(3\\) . Este paso está relacionado con los años bisiestos. Calculamos el resto de la división del número del primer paso entre 7 . Por ejemplo \\(69 = 9 \\cdot 7 + 6\\) Por último sumamos los números del segundo y tercer paso y obtenemos la clave para el año. \\(3 + 6 = 9 \\equiv 2\\) 2. Comprobar el resultado Una vez tengamos todas las claves basta con sumarlas, simplificar el resultado para que nos quede un número entre 0 y 6. Comprobar el resultado con la siguiente tabla: Día de la semana Clave Domingo 0 Lunes 1 Martes 2 Miércoles 3 Jueves 4 Viernes 5 Sábado 6 Para la fecha 16 de julio de 1969 , tendríamos: \\(2 + 6 + 0 + 3 + 6 = 17 \\equiv 3\\) Por tanto ese día fue un miércoles . 3. Consideración de años bisiestos Si la fecha para la cual estamos calculando el día de la semana. Se trata de un año bisiesto y el mes es enero o febrero, al resultado final deberemos restar una unidad. Definición año bisiesto En el calendario que usamos actualmente que es el calendario Gregoriano, vigente desde 1582. Para nuestro calendario la definición de un año bisiesto es la siguiente: Un año es bisiesto si es divisible por 4, excepto si acaba en 00, que ha de ser divisible entre 400. Es decir 1600 y 2000 son años bisiestos, sin embargo 1700, 1800 y 1900 no son años bisiestos. Ejemplo año bisiesto Calculemos el día de la semana para la fecha 1 de enero de 2020 . \\(1 + 0 + 6 + 5 + 6 = 18 \\equiv 4\\) Pero debemos restar uno, ya que el año es bisiesto y el mes enero, por tanto el resultado es \\(3\\) . Es decir, un miércoles .","tags":"Matemáticas","url":"day-of-week-tutorial","loc":"day-of-week-tutorial"},{"title":"Mi primer plugin en VIM","text":"Tras usar Vim durante un largo periodo de tiempo, he decidido aventurarme a hacer mi primer plugin. Se trata de un plugin muy sencillo que simplemente te permite iterar una lista de posibles diccionarios para la corrección ortográfica. La idea es que sea posible activar el corrector ortográfico ( :set spell ) en caso de que este desactivado e ir iterando por una lista configurable de idiomas. let g :SpellLangList = get ( g : , 'SpellLangList' , [] ) \" Cycle through spelllang list and toggle spell function ! ToggleCycleSpellLang () if ! & spell setlocal spell else let l :lang_index = index ( g :SpellLangList , & spelllang ) let l :lang_index = ( l :lang_index + 1 ) % len ( g :SpellLangList ) let & spelllang = g :SpellLangList[ l :lang_index] if l :lang_index == 0 setlocal nospell endif endif endfunction Se podría configurar por ejemplo con las siguientes opciones: let g :SpellLangList = [ \"en_us\" , \"es\" , \"en_us,es\" ] nnoremap < F6 > : call ToggleCycleSpellLang ()< CR > De esta manera una primera pulsación de la tecla F6 activaría la corrección ortográfica para el buffer activo, y sucesivas pulsaciones irían cambiando el idioma activo ( :set spelllang=es ) iterando la lista g:SpellLangList hasta desactivar de nuevo la corrección ortográfica ( :set nospell ). He subido el plugin a un repositorio en github y añadido alguna funcionalidad, relacionada con las ventanas quickfix y location .","tags":"Programación","url":"my-first-vim-plugin","loc":"my-first-vim-plugin"},{"title":"Objetos mutables en python","text":"Supongamos que tenemos definida en python la siguiente función: def f ( x , l = []): for i in range ( x ): l . append ( i ) print ( l ) Si tuviésemos que decir cual es el resultado de hacer las siguientes llamadas sucesivas a la función, muchos pensareis que el resultado que se obtendría es: >>> f ( 2 ) [ 0 , 1 ] >>> f ( 3 , [ 3 , 4 , 5 ]) [ 3 , 4 , 5 , 0 , 1 , 2 ] >>> f ( 3 ) # RESULTADO ERRONEO [ 0 , 1 , 2 ] Sin embargo, el resultado que obtenemos es el siguiente: >>> f ( 2 ) [ 0 , 1 ] >>> f ( 3 , [ 3 , 4 , 5 ]) [ 3 , 4 , 5 , 0 , 1 , 2 ] >>> f ( 3 ) # RESULTADO CORRECTO [ 0 , 1 , 0 , 1 , 2 ] Esto es debido a que las listas en python son objetos mutables y por tanto cuando son definidos como parámetros por defecto en una función, la lista se comporta como una variable global a todas las ejecuciones de la función. Cuando llamamos a f(2) por primera vez se utiliza [] que es el valor por defecto de la lista. Pero cuando se ejecuta f(3) se utiliza la misma variable global que cuando se llamó a f(2) cuyo ultimo valor es [0, 1] . Tabla de objetos en python Objeto Mutable bool No int No float No list Sí tuple No str No set Sí frozenset No dict Sí Los objetos mutables en python son pasados por referencia. A diferencia del resto que es como si fuesen pasados por valor (ya que son inmutables). Un ejemplo de ello es el siguiente código: def f ( l ): l . append ( 23 ) >>> l = [ 37 ] >>> f ( l ) >>> print ( l ) [ 37 , 23 ]","tags":"Programación","url":"python-mutable-objects","loc":"python-mutable-objects"},{"title":"Tutorial resolver cubo a ciegas","text":"Resolver por primera vez el cubo de Rubik es un momento emocionante. Sin embargo, esta sensación no es comparable a lo que se siente al resolver el cubo a ciegas por primera vez. En esta nueva entrada os dejo una serie de videos en los que os explico como poder resolver el cubo de Rubik a ciegas. Recordad que nada se consigue de la noche a la mañana, pero cuando se consigue, ese esfuerzo se ve recompensado. Aún recuerdo la primera vez que conseguí hacer mi primer cubo de Rubik a ciegas, allá por el 2013. Y solo puedo animaros a conseguirlo si ese es vuestro objetivo.","tags":"Rubik","url":"tutorial-resolver-cubo-a-ciegas","loc":"tutorial-resolver-cubo-a-ciegas"},{"title":"My first Vim plugin","text":"After been using Vim for a long time. I've decided to venture into the creation of my first vim plugin. It's a very simple plugin that allows you to iterate over a list of possible dictionaries used for spell checking. The idea is to be able to activate the spell checking ( :set spell ) in case it is deactivated and iterate over a configurable list of languages. The following function accomplish the objective. let g :SpellLangList = get ( g : , 'SpellLangList' , [] ) \" Cycle through spelllang list and toggle spell function ! ToggleCycleSpellLang () if ! & spell setlocal spell else let l :lang_index = index ( g :SpellLangList , & spelllang ) let l :lang_index = ( l :lang_index + 1 ) % len ( g :SpellLangList ) let & spelllang = g :SpellLangList[ l :lang_index] if l :lang_index == 0 setlocal nospell endif endif endfunction It'll be possible to configure the list of languages and the keybindings as follows: let g :SpellLangList = [ \"en_us\" , \"es\" , \"en_us,es\" ] nnoremap < F6 > : call ToggleCycleSpellLang ()< CR > Consequently pressing F6 will enable spell check for the current buffer ( :set spell ), and pressing F6 successively will be changing current language used for spell checking ( :set spelllang=es ) until finally disable spell check again ( :set nospell ). I've uploaded the plugin to a github repository, and I've added similar funcionality related with quickfix and location windows.","tags":"Programming","url":"en/my-first-vim-plugin","loc":"en/my-first-vim-plugin"},{"title":"Mutable objects in python","text":"Let's assume we have defined the following function: def f ( x , l = []): for i in range ( x ): l . append ( i ) print ( l ) If we have to guess what is the output of these calls to the function. A lot of us will think is: >>> f ( 2 ) [ 0 , 1 ] >>> f ( 3 , [ 3 , 4 , 5 ]) [ 3 , 4 , 5 , 0 , 1 , 2 ] >>> f ( 3 ) # WRONG RESULT [ 0 , 1 , 2 ] However, the correct result is: >>> f ( 2 ) [ 0 , 1 ] >>> f ( 3 , [ 3 , 4 , 5 ]) [ 3 , 4 , 5 , 0 , 1 , 2 ] >>> f ( 3 ) # CORRECT RESULT [ 0 , 1 , 0 , 1 , 2 ] This is due to the fact that lists in python are mutable objects , and therefore whenever they are defined as default parameters in a function, the list behaves as a global variable common to all function's executions. When we call to f(2) for the first time, the value [] is being used by default. But when f(3) is executed the same global variable used when f(2) was called is used, which last value is [0, 1] . Table of objects in python Object Mutable bool No int No float No list Yes tuple No str No set Yes frozenset No dict Yes Mutable objects in python are passed by reference. Immutable objects is like they were being passed by value. An example of that is the following code: def f ( l ): l . append ( 23 ) >>> l = [ 37 ] >>> f ( l ) >>> print ( l ) [ 37 , 23 ]","tags":"Programming","url":"en/python-mutable-objects","loc":"en/python-mutable-objects"}]};